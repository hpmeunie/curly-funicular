<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AV Schedule — Mobile</title>

  <!-- PapaParse for robust CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root{
      --max-width: 760px;
      --accent: #007aff;
      --bg-light: #f5f6f8;
      --bg-dark: #0b0b0d;
      --card-light: rgba(255,255,255,0.85);
      --card-dark: #1f1f21;
      --text-light: #0b0b0d;
      --text-dark: #f2f2f5;
      --muted: #6b6b6f;
      --border-light: #e6e6ea;
      --border-dark: #2b2b2d;
    }

    /* Page */
    html,body { height:100%; margin:0; }
    body{
      font-family:-apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Arial, sans-serif;
      background:var(--bg-light);
      color:var(--text-light);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding-top:108px; /* header + filter bar */
      display:flex;
      justify-content:center;
      box-sizing:border-box;
    }

    @media (prefers-color-scheme: dark) {
      body{
        background:var(--bg-dark);
        color:var(--text-dark);
      }
    }

    /* Container */
    .app {
      width:100%;
      max-width:var(--max-width);
      padding:0 12px 40px;
      box-sizing:border-box;
    }

    /* Frosted header */
    header.app-header {
      position:fixed; top:0; left:0; right:0;
      height:56px; display:flex; align-items:center; justify-content:center;
      backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
      z-index:30;
      background: rgba(255,255,255,0.72);
      border-bottom: 1px solid var(--border-light);
      font-weight:600; font-size:1.05rem; color:var(--accent);
    }
    @media (prefers-color-scheme: dark){
      header.app-header{
        background: rgba(16,16,17,0.72);
        border-bottom:1px solid var(--border-dark);
      }
    }

    /* Filter bar (below header, sticky) */
    .filter-bar {
      position:fixed; top:56px; left:0; right:0;
      z-index:25;
      display:flex; align-items:center; justify-content:center;
      padding:10px 12px; gap:12px;
      background: rgba(255,255,255,0.66);
      border-bottom:1px solid var(--border-light);
      backdrop-filter: blur(6px);
    }
    @media (prefers-color-scheme: dark){
      .filter-bar{ background: rgba(16,16,17,0.66); border-bottom:1px solid var(--border-dark); }
    }

    /* Room select */
    .room-select {
      min-width:160px;
      max-width:90%;
      width:320px;
      padding:10px 14px;
      border-radius:12px;
      border:1px solid var(--border-light);
      background: var(--card-light);
      font-weight:600;
      color: inherit;
      -webkit-appearance:none; appearance:none;
      box-shadow: 0 6px 18px rgba(0,0,0,0.06);
    }
    @media (prefers-color-scheme: dark){
      .room-select { background: var(--card-dark); border:1px solid var(--border-dark); }
    }

    /* Schedule area */
    .schedule {
      margin-top: 12px;
      display:flex; flex-direction:column; gap:18px;
    }

    /* Day section header (sticky within flow) */
    .day-section {
      /* spacer around each day */
    }
    .day-header {
      position: sticky;
      top: 112px; /* header (56) + filter (56) */
      background: transparent;
      font-weight:700;
      font-size:0.98rem;
      padding:6px 8px;
      color: var(--muted);
      z-index:20;
    }
    @media (prefers-color-scheme: dark){
      .day-header { color: #9b9b9f; }
    }

    /* Cards list per day */
    .day-cards { display:flex; flex-direction:column; gap:12px; padding-bottom: 4px; }

    .card {
      border-radius:14px;
      padding:14px;
      background: var(--card-light);
      border: 1px solid var(--border-light);
      box-shadow: 0 6px 20px rgba(0,0,0,0.06);
      transition: transform .18s ease, opacity .12s ease;
      overflow: hidden;
    }
    @media (prefers-color-scheme: dark){
      .card { background: var(--card-dark); border:1px solid var(--border-dark); }
    }
    .card:hover { transform: translateY(-2px); }

    .card-row {
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }

    .card-left { flex:1 1 auto; min-width:0; }
    .card-right { flex:0 0 auto; text-align:right; font-weight:600; color:var(--accent); min-width:72px; }

    .room { font-weight:700; font-size:0.98rem; margin-bottom:4px; color:inherit; }
    .session { color:inherit; opacity:0.95; font-size:0.94rem; margin-bottom:6px; }
    .meta { font-size:0.86rem; color:var(--muted); }
    @media (prefers-color-scheme: dark){ .meta { color:#9b9b9f; } }

    /* small screens */
    @media (max-width:420px){
      .room-select { width:180px; min-width:120px; }
      .card { padding:12px; border-radius:12px; }
      .card-right { min-width:64px; font-size:0.92rem; }
    }
  </style>
</head>
<body>
  <header class="app-header">AV Daily Schedule</header>

  <div class="filter-bar">
    <select id="roomFilter" class="room-select" aria-label="Filter by room">
      <option value="all">All Rooms</option>
    </select>
  </div>

  <main class="app" id="app">
    <div id="schedule" class="schedule" aria-live="polite"></div>
  </main>

<script>
/*
  Behavior:
  - Loads CSV "Production Schedule Template - Sheet1 (4).csv" (same folder)
  - Uses "Day" column to group sessions; shows each Day as a section header above its cards
  - Cards show Room, Session, Time, Tech, Gear (no Day inside card)
  - Room filter filters sessions across all Day groups
  - Skips non-session rows (Session equals Day text, missing Room, or missing Session)
*/

// CSV file name (must be in same folder)
const CSV_FILE = "Production Schedule Template - Sheet1 (4).csv";

function isNonSessionRow(row) {
  // Consider non-session if missing Room or Session, or session text equals the Day label
  if (!row || !row.Session || !row.Room) return true;
  const sess = String(row.Session).trim().toLowerCase();
  const day  = String(row.Day || "").trim().toLowerCase();
  if (day && sess === day) return true;
  // also ignore obvious headings like "tuesday" in Room or Session
  if (sess.length <= 2) return true;
  return false;
}

// parse & render
function loadAndRender() {
  Papa.parse(CSV_FILE, {
    download: true,
    header: true,
    skipEmptyLines: true,
    complete: function(results) {
      const raw = results.data || [];
      // clean rows: keep rows that look like sessions and have Day
      const rows = raw.filter(r => !isNonSessionRow(r) && r.Day);

      // normalize Day label (trim)
      rows.forEach(r => { r.Day = (r.Day || "").toString().trim(); });

      // build unique sorted list of days in CSV order
      const dayOrder = [];
      rows.forEach(r => {
        const d = r.Day;
        if (!dayOrder.includes(d)) dayOrder.push(d);
      });

      // build index per day
      const byDay = {};
      dayOrder.forEach(d => byDay[d] = []);
      rows.forEach(r => {
        const d = r.Day;
        if (!byDay[d]) byDay[d] = [];
        byDay[d].push(r);
      });

      // populate room filter choices (unique rooms)
      const roomSet = new Set(rows.map(r => r.Room).filter(Boolean));
      populateRoomFilter([...roomSet].sort());

      // initial render (no filter)
      renderGrouped(byDay, dayOrder);
    },
    error: function(err) {
      console.error("CSV load error:", err);
      document.getElementById("schedule").textContent = "Failed to load schedule.";
    }
  });
}

function populateRoomFilter(rooms) {
  const sel = document.getElementById("roomFilter");
  // Remove existing except 'All Rooms'
  sel.querySelectorAll("option:not([value='all'])").forEach(o=>o.remove());
  rooms.forEach(r=>{
    const opt = document.createElement("option");
    opt.value = r;
    opt.textContent = r;
    sel.appendChild(opt);
  });

  sel.onchange = () => {
    // reload CSV data then filter via selected room
    applyFilterAndRender(sel.value);
  };
}

// We keep a lightweight cache to avoid reparsing CSV repeatedly
let lastByDay = null;
let lastDayOrder = null;

function applyFilterAndRender(selectedRoom) {
  // if no cached data, reload
  if (!lastByDay) {
    loadAndRender();
    return;
  }
  // filter each day's list
  const filtered = {};
  lastDayOrder.forEach(d => {
    const list = lastByDay[d].filter(r => {
      if (!r) return false;
      if (!selectedRoom || selectedRoom === "all") return true;
      return String(r.Room).trim().toLowerCase() === String(selectedRoom).trim().toLowerCase();
    });
    filtered[d] = list;
  });
  renderGrouped(filtered, lastDayOrder);
}

function renderGrouped(byDay, dayOrder) {
  // cache
  lastByDay = byDay;
  lastDayOrder = dayOrder;

  const container = document.getElementById("schedule");
  container.innerHTML = "";

  dayOrder.forEach(day => {
    const items = byDay[day] || [];
    if (!items.length) return; // skip empty day after filtering

    // day header
    const section = document.createElement("section");
    section.className = "day-section";

    const header = document.createElement("div");
    header.className = "day-header";
    header.textContent = day; // show day as section header (user requested)
    section.appendChild(header);

    const dayCards = document.createElement("div");
    dayCards.className = "day-cards";

    // sort day items by Time (attempt parsing hh:mm AM/PM or 24-hour)
    items.sort((a,b) => {
      const tA = parseTimeToMinutes(a.Time);
      const tB = parseTimeToMinutes(b.Time);
      return (tA - tB);
    });

    items.forEach(item => {
      const c = createCard(item);
      if (c) dayCards.appendChild(c);
    });

    section.appendChild(dayCards);
    container.appendChild(section);
  });
}

// create a visual card for a session (no Day info inside)
function createCard(item) {
  // sanity
  if (!item || !item.Room || !item.Session) return null;

  const card = document.createElement("article");
  card.className = "card";
  card.setAttribute("role","article");

  // left: room + session + meta, right: time
  const row = document.createElement("div");
  row.className = "card-row";

  const left = document.createElement("div");
  left.className = "card-left";

  const room = document.createElement("div");
  room.className = "room";
  room.textContent = item.Room;

  const session = document.createElement("div");
  session.className = "session";
  session.textContent = item.Session;

  const meta = document.createElement("div");
  meta.className = "meta";
  let metaParts = [];
  if (item.Tech) metaParts.push("👤 " + item.Tech);
  if (item.Gear) metaParts.push("🎛️ " + item.Gear);
  meta.textContent = metaParts.join(" · ");

  left.appendChild(room);
  left.appendChild(session);
  if (metaParts.length) left.appendChild(meta);

  const right = document.createElement("div");
  right.className = "card-right";
  right.textContent = item.Time || "";

  row.appendChild(left);
  row.appendChild(right);
  card.appendChild(row);

  return card;
}

// Attempt to parse a variety of time formats into minutes-since-midnight
function parseTimeToMinutes(t) {
  if (!t) return 24*60; // push missing times to end
  const s = String(t).trim();
  // remove non-breaking spaces and weird unicode spaces
  const cleaned = s.replace(/\u00A0/g, " ").replace(/\u202F/g, " ").replace(/\s+/g, " ").trim();

  // Try formats like "6:00 PM", "18:30", "6:00 PM" (with unicode)
  const ampmMatch = cleaned.match(/(\d{1,2}):?(\d{0,2})\s*([AaPp][Mm])/);
  if (ampmMatch) {
    let hh = parseInt(ampmMatch[1],10);
    let mm = ampmMatch[2] ? parseInt(ampmMatch[2],10) : 0;
    const ampm = ampmMatch[3].toLowerCase();
    if (ampm === 'pm' && hh !== 12) hh += 12;
    if (ampm === 'am' && hh === 12) hh = 0;
    return hh*60 + mm;
  }

  // Try 24-hour "HH:MM"
  const hm = cleaned.match(/(\d{1,2}):(\d{2})/);
  if (hm) {
    const hh = parseInt(hm[1],10), mm = parseInt(hm[2],10);
    return hh*60 + mm;
  }

  // If it's a single number like "0700" or "700PM" (fallback)
  const num = cleaned.match(/(\d{1,4})/);
  if (num) {
    const n = num[1];
    if (n.length <= 2) return parseInt(n,10)*60; // "7" -> 7:00
    if (n.length === 3) { // "700" -> 7:00
      const hh = parseInt(n.slice(0,1),10), mm = parseInt(n.slice(1),10);
      return hh*60 + mm;
    }
    if (n.length === 4) { // "1730" -> 17:30
      const hh = parseInt(n.slice(0,2),10), mm = parseInt(n.slice(2),10);
      return hh*60 + mm;
    }
  }

  // Last resort: return large value so it appears at bottom
  return 24*60;
}

// initial load
loadAndRender();

</script>
</body>
</html>
